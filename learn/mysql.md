# MySQL数据库知识点整理
---

## 数据库三大范式
### 第一范式
原子性，字段（列）不可再分
### 第二范式
满足第一范式的前提下，所有字段都要完全依赖于主键（主键有多个字段构成时，不能只依赖于部分主键）
### 第三范式
满足第二范式的前提下，所有字段都应直接依赖于主键，不应该通过依赖非主键字段从而间接依赖于主键（所以要拆表）

---

## MySQL存储引擎
### InnoDB（MySQL5.5版本后的默认存储引擎）
1. 特点
   - 支持外键
   - 支持聚簇索引
   - 支持表级锁、行级锁
   - 支持事务
   - 支持崩溃后的数据恢复
2. 适用场景：适合需要事务支持，有较高并发读写频率的场景
### MyISAM
1. 特点
   - 支持表级锁
   - 访问速度快
2. 适用场景：不需要事务支持，以读为主的场景
### MEMORY
1. 特点
   - 数据都在内存中，访问速度快
   - 默认使用HASH索引，包含指向数据行的指针

---

## MySQL索引
### 索引的类型
1. 普通索引：最基本的索引，没有任何限制
2. 唯一索引：索引列的值必须唯一，允许有空值
3. 主键索引：索引列的值必须唯一（特殊的唯一索引），且不允许空值
4. 联合索引：包含多个列的索引
5. 全文索引：用于全文搜索，只能为char、varchar和text类型的列创建
### 索引的数据结构
1. **B+树索引**（InnoDB默认索引）
   - 是一颗多路平衡查询树，先序遍历结果是有序的
   - 任意叶子结点到根结点的高度均相同(查询效率稳定)，且高度较低（减少读取索引的IO次数）
   - 非叶子结点仅存储关键排序信息（单次IO能读入更多关键字，减少了IO次数）
   - 叶子结点存储数据元素，并以双向链表的结构连接（便于全表扫描或范围查询）
2. **哈希索引**（Memory引擎才有）
   - 用于精确查找，仅对等值查询生效（=,<>,IN）
   - 无法排序，无法范围查询，无法模糊查询
3. 位图索引
### 索引的组织形式
1. **聚簇索引**
   - 索引的叶子结点中同时存放了表的行记录，表中的数据也成了索引的一部分。
   - 一张表只有一个聚簇索引，通常是该表的主键索引，没有主键的话就会用第一个NOT NULL的唯一索引，再没有的话InnoDB会生成隐藏的row_id作为聚簇索引
2. **非聚簇索引**
   - 索引的叶子结点中不存储表的数据，而是存储聚簇索引的值（一般是主键）
3. **覆盖索引**
   - SELECT所需的数据列包含于索引之中，则不需要再次*回表查询*
   - *回表查询*：如果要查询的列不包含于或只部分包含于索引之中，则需要根据第一次索引查询结果（通常是主键）再去查询聚簇索引以得到完整的数据列
### 索引的最左匹配原则
- 创建列A、B的联合索引时，实际会创建{A}，{A,B}两个索引
- 在用联合索引检索数据时，从联合索引的最左边开始匹配，因此创建联合索引时应该将最常用的查询列往左边放
### 索引的优缺点
- 优点: 加快查询速度，便于数据分组与排序
- 缺点：需要额外的物理空间来存储索引结构，并且在数据增删改时需要额外的索引维护开销
### 索引的失效场景
- 用组合索引查询时未满足最左匹配原则时
- OR前后连接不同的数据列时
- 查询条件为字符串类型的列时，未给字符串值加引号时
- 以%开头的LIKE查询时
- 非HASH索引使用<>查询时
- 在索引列上执行任何计算、函数时
- MySQL查询优化器判定不走索引更快时
### 索引的设计原则
- 为经常作为查询条件的列建立索引
- 满足最左匹配原则
- 索引列的数据值区分度越高，索引效果越好
- 尽量在长度较短的列上建立索引，以减少磁盘IO次数
- 尽量不在频繁增删改的列上建立索引
- 索引不是越多越好，索引需要额外物理空间和维护的时间成本

---

## 事务
### 事务四大特性（ACID）
1. **原子性**：事务要么全部成功，要么全部失败回滚
2. **一致性**：一个事务在执行之后数据仍然处于一致性状态
   - 例：两个账户转账，两者账户金额只和保持不变
3. **隔离性**：一个事务职能读取到另一个事务已提交的改变
4. **持久性**：事务一旦提交，其对数据库的改变是永久性的
### 事务要解决的问题
1. **脏读**：事务A读到了事务B还未提交的数据
2. **不可重复读**：事务A在不同时间查询某数据时会得到不同的结果
   - 例：事务A执行过程中事务B提交了数据，导致事务A再次读取相同数据得到的结果不同
3. **幻读**：事务A范围查询时，事务B又在该范围内插入了一条新纪录，导致事务A的查询结果不再准确
   - 理解：事务A的行级锁拦不住事务B的插入操作
### 事务隔离级别
1. **读未提交**：无任何约束，所有问题均可能发生（并发度最高）
2. **读已提交**：事务A只能看见事务B已提交的改变，解决了脏读的问题
3. **可重复读**：解决了脏读和不可重复读的问题（MySQL的默认事务隔离级别）
4. **串行化**：强制对所有事务排序，解决了脏读、不可重复读和幻读的问题（并发度最低）
### 提问
1. 为什么生产环境的隔离级别大多采用读已提交（RC）而不是可重复读（RR）？
   - RR存在间隙锁，出现死锁几率比RC高得多
   - RC的并发度高于RR
   - 大部分情况下只要保证数据库中数据无误即可，不可重复读问题是可以接受的

---

## MySQL的锁
### 按锁的粒度划分
1. 行级锁：粒度最细，开销最大。有三种实现：
   - 记录锁：仅仅锁住一条记录
   - 间隙锁：条件范围查询时，InnoDB会给符合条件的索引范围加锁，该范围内并不存在的记录上的锁就叫“间隙锁”
     - 解决了幻读的问题
   - Next-Key Lock：记录锁和间隙锁的组合，锁定一个范围以及记录本身
2. 表级锁：粒度最粗，开销最小。有四种实现：
   - 表锁：锁住整张表
   - 元数据锁（MDL）：为了**防止其他线程更改表结构**，在事务期间会自动上MDL读/写锁，事务提交后自动释放
   - 意向锁（InnoDB自动添加）：表示将要申请的锁的类型，意向锁不会互相冲突，只会与已被申请的锁冲突。目的是快读判断表中记录是否被加锁
     - 意向共享锁（IS）：获取共享锁前必须先获得IS
     - 意向排他锁（IX）：获取排他锁前必须先获得IX
   - AUTO-INC锁：当存在AUTO_INCREMENT的字段时，插入数据时上表级别的AUTO-INC锁，插入完成后立即释放（无需等事务提交）。有三种模式：
     - innodb_autoinc_lock_mode=0时，使用AUTO-INC锁
     - innodb_autoinc_lock_mode=2时，使用轻量级锁（字段自增完成即释放，不需要等整条插入语句）
     - innodb_autoinc_lock_mode=1时，以上两种混合，能确定插入记录的数量就用轻量级锁，不能确定则用AUTO-INC锁
3. 页级锁（InnoDB）：粒度适中，会锁住相邻的一组记录
4. 全局锁：主要用于全局逻辑备份时上锁
   - 上锁：FLUSH TABLES WITH READ LOCK；解锁：UNLOCK TABLES
### 按锁的类别划分
1. 共享锁（读锁）
   - SELECT * FROM table WHERE id<5 LOCK **IN SHARE MODE**
2. 排他锁（写锁）
   - SELECT * FROM table WHERE id<5 LOCK **FOR UPDATE**
### 按锁的思想划分
1. 乐观锁：事务只在提交数据时检查数据是否被更改过，一般通过版本号机制或者CAS算法实现
2. 悲观锁：事务过程中一直持有排他锁，直至事务被提交

---

## MySQL主从同步
将数据从主服务器（Master）同步复制到其他的从服务器（Slave）上，同步过程是异步进行的
### 优点
1. 读写分离，主服务器负责数据写入，从服务器提供数据读取，降低了主服务器流量压力，提高了数据库的并发能力
2. 数据备份，提高安全性

---

## MySQL日志
### bin log
### redo log
### undo log

---

## MySQL分库分表
当单表数据量过多（1000万条）时，为了防止查询性能的大幅下降，需要考虑分库分表
### 垂直划分
根据业务对表进行字段上的切分，将一张多字段的表切分成几张少字段的表
- 优点
  - 单条行记录变小，一页数据页内可以存放更多条记录，从而减少查询时的IO次数
- 缺点
  - 拆分后会出现冗余列，一般主键容易冗余
  - 会导致相同的查询需要额外的JOIN操作，增加数据库压力
  - 拆分后单表内的数据条数并没有减少
### 水平划分
根据一定规则，例如数据的更新时间等对数据进行拆分，将一张大数据量的表拆分成多张小数据量的表，数据总量保持不变
- 优点
  - 单表数据量能显著减少，提高性能
  - 切分出的所有表结构一致，程序改动较小
- 缺点
  - 事务一致性问题难以解决
  - 跨节点JOIN性能差逻辑复杂